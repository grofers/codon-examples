package {{ .Name }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
  "net/http"
  "github.com/go-openapi/errors"
  httptransport "github.com/go-openapi/runtime/client"
  "github.com/go-openapi/swag"
  "github.com/go-openapi/runtime"
  "github.com/go-openapi/validate"

  strfmt "github.com/go-openapi/strfmt"

  {{ range .DefaultImports }}{{ printf "%q" .}}
  {{ end }}
  {{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
  {{ end }}
)

// New creates a new {{ humanize .Name }} API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
  return &Client{transport: transport, formats: formats}
}

/*
Client {{ if .Summary }}{{ .Summary }}{{ if .Description }}

{{ .Description }}{{ end }}{{ else if .Description}}{{ .Description }}{{ else }}for {{ humanize .Name }} API{{ end }}
*/
type Client struct {
  transport runtime.ClientTransport
  formats strfmt.Registry
}

{{ range .Operations }}/*
{{ pascalize .Name }} {{ if .Summary }}{{ pluralizeFirstWord (humanize .Summary) }}{{ if .Description }}

{{ .Description }}{{ end }}{{ else if .Description}}{{ .Description }}{{ else }}{{ humanize .Name }} API{{ end }}
*/
func (a *Client) {{ pascalize .Name }}(all_params map[string]interface{}) {{ if .SuccessResponse }}({{ range .SuccessResponses }}*{{ pascalize .Name }}, {{ end }}{{ end }}error{{ if .SuccessResponse }}){{ end }} {
  {{ $length := len .SuccessResponses }}
  params, err := New{{ pascalize .Name }}ParamsFromMap(all_params)
  if err != nil {
    return {{ if .SuccessResponse }}{{ padSurround "nil" "nil" 0 $length }}, {{ end }}err
  }
  {{ if .Authorized }}
  var authInfo runtime.ClientAuthInfoWriter
  if _, ok := all_params["BasicAuthUsername"]; ok {
    authInfo = httptransport.BasicAuth(all_params["BasicAuthUsername"].(string), all_params["BasicAuthPassword"].(string))
  }
  {{ end }}
  {{ if .HasStreamingResponse }}
  var writer io.Writer
  writer = all_params["StreamingWriter"].(io.Writer)
  {{ end }}
  {{ if .SuccessResponse }}result{{else}}_{{ end }}, err := a.transport.Submit(&runtime.ClientOperation{
    ID: {{ printf "%q" .Name }},
    Method: {{ printf "%q" .Method }},
    PathPattern: {{ printf "%q" .Path }},
    ProducesMediaTypes: {{ printf "%#v" .ProducesMediaTypes }},
    ConsumesMediaTypes: {{ printf "%#v" .ConsumesMediaTypes }},
    Schemes: {{ printf "%#v" .Schemes }},
    Params: params,
    Reader: &{{ pascalize .Name }}Reader{formats: a.formats{{ if .HasStreamingResponse }}, writer: writer{{ end }}},{{ if .Authorized }}
    AuthInfo: authInfo,{{ end}}
    Context: params.Context,
    Client: params.HTTPClient,
  })
  if err != nil {
    return {{ if .SuccessResponse }}{{ padSurround "nil" "nil" 0 $length }}, {{ end }}err
  }
  {{ if .SuccessResponse }}{{ if eq $length 1 }}return result.(*{{ pascalize .SuccessResponse.Name }}), nil{{ else }}switch value := result.(type) { {{ range $i, $v := .SuccessResponses }}
    case *{{ pascalize $v.Name }}:
      return {{ padSurround "value" "nil" $i $length }}, nil{{ end }} }
  return {{ padSurround "nil" "nil" 0 $length }}, nil{{ end }}
  {{ else }}return nil{{ end }}

}
{{ end }}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
  a.transport = transport
}
